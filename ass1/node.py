import random
from transaction import Transaction
from event_queue import event_queue
from params import *
from event import Event
from packet import Packet

class Node:
    """
    Represents a node in the network
    """ 
    
    available_txn_id = 0
    
    def __init__(self,id:int,slow:bool,low_cpu:bool,peers:list) -> None:
        """Initializes a new node in the network
        Args:
            id (int): Unique descriptor of the node
            slow (bool): relative measure of the node's network speed
            low_cpu (bool): relative measure of the node's CPU speed
            peers (list): list of peers of the node
        """
        
        self.id = id
        self.slow = slow
        self.low_cpu = low_cpu
        self.peers = peers
        self.time_last_txn_gen = 0
        self.generate_txn()
        self.txns = []
        self.seen_txn_ids = set()
     
    def __str__(self) -> str:
        """
        prints the node's id, peers, slow and low_cpu
        Returns:
            str: string representation of the node
        """
        return f"Node {self.id} has peers {self.peers} and is slow: {self.slow} and has low cpu: {self.low_cpu}\n"
    
    def generate_txn(self) -> None:
        """
        generates a transaction for the node

        Returns:
            Transaction: transaction generated by the node
        """
        
        # get a unique transaction id
        txnId = Node.available_txn_id
        Node.available_txn_id += 1
        # generate a random receiver
        receiver_id = random.randint(0,n-1)
        # avoid self transactions
        if receiver_id == self.id:
            receiver_id = (receiver_id+1)%n
        # generate a random amount
        amount = random.randint(1,50)
        # create a new transaction
        txn = Transaction(txnId,self.id,receiver_id,amount)
        # find the time at which the transaction is generated
        trigger_time = self.time_last_txn_gen + random.expovariate(1/inter_txn_time)
        # creat a fake receive event from -1 to self.id
        txn_receive_event = Event(trigger_time,RECEIVE_TXN,self.id,Packet(-1,self.id,txn))
        # create next transaction generation event
        next_txn_gen_event = Event(trigger_time,GENERATE_TXN,self.id,None)
        # add the events to the event queue
        event_queue.add_event(txn_receive_event)
        event_queue.add_event(next_txn_gen_event)
        # update the time of last transaction generation
        self.time_last_txn_gen = trigger_time
    
    def receive_txn(self,packet:Packet,received_time:float,transmission_delay:list,internet_speed:list) -> None:
        """Receives a transaction from a peer

        Args:
            packet (Packet): packet containing the transaction
            received_time (float): time at which the packet is received
            transmission_delay (list): list of transmission delays between nodes
            internet_speed (list): list of internet speeds between nodes
        """
        # get the sender id and the transaction
        sender_id = packet.source
        txn = packet.data
        
        # if the transaction has already been seen, return do nothing
        if txn.id in self.seen_txn_ids:
            return
        # else add the transaction to the list of transactions and the set of seen transactions
        self.txns.append(txn)
        self.seen_txn_ids.add(txn.id)
        
        # loop over all peers and send the transaction to them
        for peer in self.peers:
            # if the peer is the sender, do not send the transaction back
            if peer != sender_id:
                # time_to_send = transmission_delay + propagation_delay + queuing_delay
                time_to_send = transmission_delay[self.id][peer]
                if internet_speed[self.id][peer]:
                    time_to_send += SIZE_TXN/c_fast
                    time_to_send += random.expovariate(c_fast/queuing_delay_constant)
                else:
                    time_to_send += SIZE_TXN/c_slow
                    time_to_send += random.expovariate(c_slow/queuing_delay_constant)
                # add the event to the recieve event queue
                event_queue.add_event(Event(received_time+time_to_send,RECEIVE_TXN,peer,Packet(self.id,peer,txn)))

        
        
        